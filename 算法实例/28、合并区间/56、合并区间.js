// 难度：中等

// 题目：
// 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

// 示例 1：

// 输入：intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
// 输出：[[1, 6], [8, 10], [15, 18]]
// 解释：区间[1, 3] 和[2, 6] 重叠, 将它们合并为[1, 6].

//     示例 2：

// 输入：intervals = [[1, 4], [4, 5]]
// 输出：[[1, 5]]
// 解释：区间[1, 4] 和[4, 5] 可被视为重叠区间。

// 提示：

// 1 <= intervals.length <= 104
// intervals[i].length == 2
// 0 <= starti <= endi <= 104

// 解题思路：
// 解这道题，关键在于理解如何合并重叠的区间。一种有效的策略是首先对区间按起始位置进行排序，然后遍历排序后的区间列表，比较当前区间的结束位置与下一个区间的起始位置，如果发现重叠，则合并这两个区间。

// 排序：首先，对输入的区间列表按照每个区间的起始位置进行升序排序。这样可以确保我们在遍历时能从左到右处理区间，更容易发现和处理重叠。
// 合并：遍历排序后的区间列表。对于每个区间，如果它的起始位置在结果数组的最后一个区间的结束位置之后，说明它们不重叠，直接将其加入结果数组。否则，说明有重叠，此时更新结果数组中最后一个区间的结束位置，使其覆盖当前区间的结束位置。
// 终止条件：遍历完整个区间列表后，结果数组即为合并后不重叠的区间列表。

/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
function merge(intervals) {
    // 第一步：按照区间起始位置排序
    intervals.sort((a, b) => a[0] - b[0]);
    // 初始化结果数组，至少包含第一个区间
    const merged = [intervals[0]];
    // 遍历排序后的区间列表
    for (let i = 1; i < intervals.length; i++) {
        const current = intervals[i];
        const lastMerged = merged[merged.length - 1];

        // 如果当前区间的起始位置在上一区间结束位置之后，说明无重叠，直接添加
        if (current[0] > lastMerged[1]) {
            merged.push(current);
        } else {
            // 否则，有重叠，更新上一区间的结束位置
            lastMerged[1] = Math.max(lastMerged[1], current[1]);
        }
    }
    return merged;
}
// 示例
// const intervals = [[1,3],[2,6],[8,10],[15,18]];
// console.log(merge(intervals)); // 输出: [[1,6],[8,10],[15,18]]
// 这段代码首先定义了merge函数，它接收一个二维数组intervals作为输入，每个子数组代表一个区间。函数内部首先对区间进行排序，然后通过遍历和比较来合并重叠的区间，并将最终结果存储在merged数组中。最后，返回这个不包含重叠区间的数组。
